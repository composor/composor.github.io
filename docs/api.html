<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="description" content="Composi is a JavaScript library for creating component-based interfaces. It uses the virtual dom to make efficient updates to the DOM based on a component's data or state.">
  <meta name="keywords" content="javascript, framework, performance, small, fast, UI, programming, code, component, composi, chocolatechipui, chocolatechip-ui, reactive, virtual dom">
  <title>Composi - Docs</title>
  <link rel="stylesheet" href="../css/styles.css">
  <link rel="stylesheet" href="../css/styles.css">
  <link rel="stylesheet" href="../css/prism-tomorrow.css">
</head>
<body class='documentation-page'>
  <nav>
    <ul class='nav--menu'>
      <li class='nav--menu__item'>
        <a class='nav--menu__item__link' href="../index.html">
          <svg id='composi-logo' viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <title>Composi Logo</title>
            <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
              <g id="Composi-Logo-Solid" fill="#fff">
                <path d="M1.77635684e-15,0 L95,0 L95,38 L209,38 L209,0 L300,0 L300,94 L265,93.8571663 L265,209 L300,209 L300,300 L209,300 L209,265 L95,265 L95,300 L1.77635684e-15,300 L1.77635684e-15,209 L40,209 L40,94 L1.77635684e-15,93.8571663 L1.77635684e-15,0 Z M107,107 L107,192 L192,192 L192,107 L107,107 Z" id="Combined-Shape"></path>
              </g>
            </g>
          </svg>
        <span class='logo__link--text'>Composi</span></a>
      </li>
      <li class='nav--menu__item selected'>
        <a class='nav--menu__item__link' href="./installation.html">Docs</a>
      </li>
      <li class='nav--menu__item'>
        <a class='nav--menu__item__link' href="../tuts/index.html">Tutorials</a>
      </li>
      <li class='nav--menu__item'>
        <a class='nav--menu__item__link external' target='__blank' href="https://github.com/composor/awesome-composi">Resources
        <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="14px" height="14px" viewBox="0 0 511.626 511.627" style="enable-background:new 0 0 511.626 511.627;"
	 xml:space="preserve">
  <path fill='#fff' d="M392.857,292.354h-18.274c-2.669,0-4.859,0.855-6.563,2.573c-1.718,1.708-2.573,3.897-2.573,6.563v91.361
    c0,12.563-4.47,23.315-13.415,32.262c-8.945,8.945-19.701,13.414-32.264,13.414H82.224c-12.562,0-23.317-4.469-32.264-13.414
    c-8.945-8.946-13.417-19.698-13.417-32.262V155.31c0-12.562,4.471-23.313,13.417-32.259c8.947-8.947,19.702-13.418,32.264-13.418
    h200.994c2.669,0,4.859-0.859,6.57-2.57c1.711-1.713,2.566-3.9,2.566-6.567V82.221c0-2.662-0.855-4.853-2.566-6.563
    c-1.711-1.713-3.901-2.568-6.57-2.568H82.224c-22.648,0-42.016,8.042-58.102,24.125C8.042,113.297,0,132.665,0,155.313v237.542
    c0,22.647,8.042,42.018,24.123,58.095c16.086,16.084,35.454,24.13,58.102,24.13h237.543c22.647,0,42.017-8.046,58.101-24.13
    c16.085-16.077,24.127-35.447,24.127-58.095v-91.358c0-2.669-0.856-4.859-2.574-6.57
    C397.709,293.209,395.519,292.354,392.857,292.354z"/>
  <path fill='#fff' d="M506.199,41.971c-3.617-3.617-7.905-5.424-12.85-5.424H347.171c-4.948,0-9.233,1.807-12.847,5.424
    c-3.617,3.615-5.428,7.898-5.428,12.847s1.811,9.233,5.428,12.85l50.247,50.248L198.424,304.067
    c-1.906,1.903-2.856,4.093-2.856,6.563c0,2.479,0.953,4.668,2.856,6.571l32.548,32.544c1.903,1.903,4.093,2.852,6.567,2.852
    s4.665-0.948,6.567-2.852l186.148-186.148l50.251,50.248c3.614,3.617,7.898,5.426,12.847,5.426s9.233-1.809,12.851-5.426
    c3.617-3.616,5.424-7.898,5.424-12.847V54.818C511.626,49.866,509.813,45.586,506.199,41.971z"/>
</svg></a>
      </li>
    </ul>
  </nav>
  <article class='docs__article'>
    <section>
      <div class='docs'>
          <h1>API</h1>
          <p class="docs__intro">Composi is only 3KB. That means the API surface is fairly small. Composi exposes the four functions (h, render, createElement and Fragment) and one class (Component) with  four properties and four methods and five life cycle hooks.</p>

          <ul>
            <li><a href="#h">h</a> {function}</li>
            <li><a href="#render">render</a> {function}</li>
            <li><a href="#createElement">createElement</a> {function}</li>
            <li><a href="#fragment">Fragment</a> {function}</li>
            <li><a href="#Component">Component</a> {class}
              <ul>
                <li>Component - (<code>property</code>) <a href="#container">container</a></li>
                <li>Component - (<code>method</code>) <a href="#render2">render</a></li>
                <li>Component - (<code>method</code>) <a href="#update">update</a></li>
                <li>Component - (<code>property</code>) <a href="#state">state</a></li>
                <li>Component - (<code>method</code>) <a href="#setState">setState</a></li>
                <li>Component - (<code>method</code>) <a href="#unmount">unmount</a></li>
                <li>Component - (<code>property</code>) <a href="#element">element</a></li>
                <li>Component - (<code>property</code>) <a href="#componentShouldUpdate">componentShouldUpdate</a></li>
                <a name='h'></a>
                <h4><code>Life Cycle Hooks:</code></h4>
                <li>Component - (<code>method</code>) <a href="#componentWillMount">componentWillMount</a> (Before version 1.2.0: <code>beforeCreateComponent</code></li>
                <li>Component - (<code>method</code>) <a href="#componentDidMount">componentDidMount</a> (Before version 1.2.0: <code>componentWasCreated</code></li>
                <li>Component - (<code>method</code>) <a href="#componentWillUpdate">componentWillUpdate</a></li>
                <li>Component - (<code>method</code>) <a href="#componentDidUpdate">componentDidUpdate</a></li>
                <li>Component - (<code>method</code>) <a href="#componentWillUnmount">componentWillUnmount</a></li>
              </ul>
              <li> <a href="#dangerouslySetInnerHTML">dangerouslySetInnerHTML</a> - (<code>A property</code>)</li>
            </li>
          </ul>

            <h2>h</h2>
            <p>The <code>h</code> function serves two purposes. Firstly it gets used by Babel during build to convert JSX into a virtual node that Composi can use for diffing and patching the dom. Secondly it provides a way to define component markup without using JSX.</p>
            <p><code>h</code> takes three arguments:</p>
            <ul>
              <li>type - The type of node to create. This is indicated by providing a lowercase tag name: "ul", "li", "div", etc.</li>
              <li>props - An object literal of properties and their values: {class: 'list-users'}</li>
              <li>children - Either a simple string for a text node, or an array of other <code>h</code> definitions: 'Hello' or [h('li')]</li>
            </ul>

            <p>To create a node you only really have to provide a type. If an element has no properties you can use and empty object: <code>{}</code> or <code>null</code>. Same for children:</p>

            <pre>
              <code class="language-javascript">
const list = h(
  // type:
  'ul',
  // props:
  {},
  // children:
  null
)
// or:
const list = h(
  // type:
  'ul',
  // props:
  null,
  // children:
  null
)
// or:
const list = h(
  // type:
  'ul'
)</code>
            </pre>
            <p>If you are creating a node that doesn't have properties but does have children, you will need to provide either <code>{}</code> or <code>null</code> or props:</p>


            <pre>
              <code class="language-javascript">
const list = h(
  // type:
  'ul',
  // props:
  {},
  // children:
  [
    h(
      // type:
      'li',
      // props:
      {},
      // child:
      'Apple'
    ),
    h(
      // type:
      'li',
      // props:
      {},
      // child:
      'Orange'
    )
  ]
)</code><a name='render'></a>
            </pre>
            <p>Of course, you would not be putting those comments in your code. That was just to make it clear how the <code>h</code> call signature works.</p>

            <h2>render</h2>
            <p>The <code>render</code> function allows you to output functional components to the DOM. It takes to arguments:</p>

            <ul>
              <li>element - Either a JSX tag, and h function or a virtual node.</li>
              <li>container - A node or CSS selector into wich the component will be rendered.</li>
            </ul>

            <p>When you inject a functional component into the DOM with <code>render</code> it also create a virtual dom scoped to where the render function was invoked. This means that invoking the same expression in a different scope with cause the creation of a new virtual dom. This will result in whatever was previously rendered being complete replaced. However, any renders after that will using the virtual dom of the current scope, resulting in efficient DOM patching.</p>

            <pre>
              <code class="language-javascript">
import {h, render} from 'composi'

const fruits = ['Apples', 'Oranges', 'Bananas']
function FruitList({fruits}) {
  return (
    &lt;ul class='list-fruits'>
      {
        fruits.map(fruit => &lt;li class='list-fruits__item'>{fruit}&lt;/li>)
      }
    &lt;/ul>
  )
}
render(<FruitList {...{fruits}} />, '#available-fruits')</code>
</pre>
            <p>And here's the same example redone to create a virtual node and pass that in. Since we are not using a JSX tag to render, we do not need to enclose the data parameter in curly braces when we call the function:</p>
            <pre>
              <code class="language-javascript">
const fruits = ['Apples', 'Oranges', 'Bananas']
// No need for curly braces in the function call:
function FruitList(fruits) {
  return (
    &lt;ul class='list-fruits'>
      {
        fruits.map(fruit => &lt;li class='list-fruits__item'>{fruit}&lt;/li>)
      }
    &lt;/ul>
  )
}
// Create the virtual node:
const fruitList = FruitList(fruits)
render(fruitList, 'section')</code><a name="createElement"></a>
</pre>
<br><br>
            
            <p> </p>
            <h2>createElement</h2>
            <p>This is not the same as the React function of the same name. This function creates a DOM node from a virtual node. If the virtual node has children, those will also be created. <code>createElement</code> lets you create nodes from JSX or from the <code>h</code> function which you can then insert directly into the DOM with <code>Element.appendChild</code> or any other DOM method that suits your purpose.</p>

          <pre>
<code class="language-javascript">import {h, createElement} from 'composi'

function Title({data}) {
  return (
    &lt;nav>
      &lt;h1>{data}&lt;/h1>
    &lt;/nav>
  )
}

const title = createElement(&lt;Title data='Hello World!'/>)
document.body.appendChild(title)

// Or:
function Title(data) {
  return h('nav', {}, [
    h('h1', {}, data)
  ])
}
const title = createElement(Title('Hello World!'))
document.body.appendChild(title)
</code></pre>
            <p>Although <code>createElement</code><a name="fragment"></a></pre> might seem useful for some edge cases, before using it think about instead using the render function. Render allows you to update the result if you ever need to, where as appending the result of <code>createElement</code> is a one time operation.</p>


            <h2>Fragment</h2>
            <p>Composi provides a <code>Fragment</code> tag to let you return multiple siblings without a wrapper tag. When <code>Fragement</code> is parsed by Composi, only the children are returned. This is useful for creating lists and tables.</p>
            
          <pre>
<code class="language-javascript">import {h, Component, Fragment} from 'composi'

function ListItems({data}) {
  return (
    &lt;Fragment>
      {
        data.map(item => &lt;li>{item}&lt;/li>)
      }
    &lt;/Fragment>
  )
}

class List extends Component {
  render(data) {
    return (
      &lt;ul class="list">
        &lt;Fragment data={data}/>
      &lt;/ul>
    )
  }
}

new List({
  container: 'section',
  state: todos
})
</code><a name='Component'></a></pre>
            <p>Please note that <code>Fragment</code> tags cannot be inserted directly into the DOM. The <code>Fragment</code> tag does not create a document fragment. It is simply a function component that returns its children for inclusion in another virtual node.</p>
            <p> </p>
            <h2>Component</h2>
            <p>The component class is the main part of Composi that you will be using. This class provides a number of properties and methods for you to use. There are two ways to use this class:</p>

            <ul>
              <li>Create a new instance.</li>
              <li>Extend it to create a new class.</li>
            </ul>

            <p>If your needs are simple, create a new instance of <code>Component</code> is a good choice. However, if you know that this component's needs may increase as you develop your app, it's better to go with exending <code>Component</code>. Extending it lets you add custom properties and methods to the class to make an event more powerful solution. If your component will involve use interactions or ocassional updates, you'll want to extend <code>Component</code>.</p>
            
            <h2>Component - new</h2>
            <p>If you just need to put together a simple component, creating a new instance of the Component class is the way to go. The class takes an object literal of certain values: container, render, optional state and lifecycle hooks. At the minimal you'll have to provide a container and render function:</p>

            <pre>
              <code class="language-javascript">
const title = new Component({
  container: 'header',
  render: (message) => <h1>Hello, {message}!</h1>
})
// Pass some data to the component to render it:
title.update('World')
              </code>
            </pre>
            <p><strong>Note:</strong> because a new instance is initialized with an object literal, the methods defined in it do not have the scope of the component. Their scope is the scope of the object literal. This makes it tricky and cumbersome to access properties and methods on the component instance. If you wish to make a component with more complex needs, do extend the <code>Component</code> class</p>
            <p>You can learn more about all container, render, state and lifecycle hooks down below.</p>

            <h2>Component - extend</h2>
            <p>You will get the most out of the Component class by extending it. This will let you create custom properties and methods for your component based on what it needs to do. When you extend <code>Component</code>, every class method with have access to the class properties and methods through its <code>this</code> keyword</p>

            <p>In the following example, notice how we added the properties <code>state</code> and <code>key</code> to the class constructor. Because we are adding properties to the contstructor, we all need to include <code>super</code> and pass it <code>props</code>. We also added a <code>render</code> function, inside of which we can easily access the component's <code>state</code> property. We also added a method called </code>handleEvent</code> to implement events. And finally a <code>componentWasCreated</code> hook to set up the main event. And finally, we use are class by instantiating it and passing it a value for the container to render in.</p>

            <pre>
              <code class="language-javascript">
class List extends Component {
  constructor(props) {
    super(propss)
    this.state = fruits
    // key to use for adding new items:
    this.key = 1000
  }
  render() {
    let state = this.state
    return (
      &lt;div>
        &lt;p>
          &lt;input id='nameInput' type='text' />
          &lt;button id='addItem'>Add&lt;/button>
        &lt;/p>
        &lt;ul id='fruitList'>
          {
            this.state.map(fruit => &lt;li key={fruit.key}>{fruit.name}&lt;/li>)
          }
        &lt;/ul>
      &lt;/div>
    )
  }
  handleEvent(e) {
    // Handle button click:
    if (e.target.id === 'addItem') {
      const nameInput = this.element.querySelector('#nameInput')
      const name = nameInput.value
      if (!name) {
        alert('Please provide a name!')
        return
      }
      this.setState({name, key: this.key++}, this.state.length)
      nameInput.value = ''
      nameInput.focus()
    // Handle list item click:
    } else if (e.target.nodeName === 'LI') {
      alert(e.target.textContent.trim())
    }
  }
  componentWasCreated() {
    this.element.addEventListener('click', this)
  }
}
const list = new List({
  container: 'section'
})</code><a name='container'></a>
            </pre>
            
            <p>&nbsp;</p>
            
            <h2>Component - container</h2>
            <p>This is a property on the component that is the base element of the component. Many components can share the same container, for example, you might have them rendered directly in the body tag. This means that the contain is not the component. When you access the component from its <code>element</code> property, you are one level down from the container.</p>

            <pre>
              <code class="language-javascript">
const list = new List({
  container: 'section'
})</code><a name='render2'></a>
            </pre>
            
            <p> </p>
            <h3>Notice:</h3> 
            <p>Once you instantiate a component, you cannot change its container. You can change the value of the component's selector or even its container value, but these changes will not affect the container currently used by the component when rendering. During initialization the component tries to get the selector provided. If the selector cannot be found in the DOM, <code>document.body</code> will be used as the container. Whatever container the component gets during intialization will remain in effective for the duration of the current session. This can only be changed by a page reload.</p>
            <p> </p>

            <h2>Component - render</h2>
            <p>This is a method defined on a component that defines the markup that the component will create. It returns a virtual node when it executes. By default when this is executed it checks for <code>state</code> to use. You can bypass this by passing data through the component's <code>update</code> method.</p>
            <pre>
              <code class="language-javascript">
class List extends Component {
  render(data) {
    return (
      &lt;ul>
        {
          data.map(item => &lt;li>{item}&lt;/li>)
        }
      &lt;/ul>
    )
  }
}</code><a name='update'></a>
            </pre>
            <p> </p>
            <h2>Component - update</h2>
            <p>If you have a component that does not have <code>state</code>, after initializing it you'll ned to execute <code>udpate</code> on it. Doing so will cause it to be rendered in the DOM. You can also optionally pass data to the <code>update</code> method. Doing so allows you to bypass the current <code>state</code> of the component.</p>
            <pre>
              <code class="language-javascript">
class Title extends Component {
  render(message) {
    return (
      <h1>Hello, {message}!</h1>
    )
  }
}
const title = new Title({
  container: 'header'
})

// Update the component:
title.update('Harry Potter')</code><a name='state'></a>
            </pre>
            
            <p> </p>
            <h2>Component - state</h2>
            <p>Components can be stateless or statefull. You use the <code>state</code> property to set that up. Once you have given your component <code>state</code>, you should use the <code>setState</code> method to update it. When you assign a value to a component's <code>state</code> property, this causes the component to be rendered to the DOM automatically. This is because the Component class has getters and setters for <code>state</code>. Whenever the setter is invoked it also invokes the component's <code>update</code> method, resulting in a render or patching of the component in the DOM.</p>

            <pre>
              <code class="language-javascript">
// Define container and state in constructor:
class Title extends Component {
  constructor(props) {
    super(props)
    this.container = 'header'
    this.state = 'Harry Potter'
  }
  render(message) {
    return (
      <h1>Hello, {message}!</h1>
    )
  }
}
const title = new Title()

//or define container and state during initialization:
class Title extends Component {
  render(message) {
    return (
      <h1>Hello, {message}!</h1>
    )
  }
}
const title = new Title({
  container: 'header',
  state: 'Harry Potter'
})</code><a name='setState'></a>
            </pre>
            
            <p> </p>
            <h2>Component - setState</h2>
            <p>This method lets you update the <code>state</code> of a component. When the compoent's state is an object or array, this lets you perform partial updates on the <code>state</code>, changing a property value of array index value. Internally, <code>setState</code> invokes the <code>state</code> setter, which cause the component to be updated.</p>

            <pre>
              <code class="language-javascript">
class Title extends Component {
  render(message) {
    return (
      <h1>Hello, {message}!</h1>
    )
  }
}
const title = new Title({
  container: 'header'
})
// Set the state with setState:
title.setState('Harry Potter')</code><a name='unmount'></a>
            </pre>
            
            <p> </p>
            <h2>Component - unmount</h2>
            <p>If you want to destroy a comonent, removing it from the DOM, you will use this method. It gets executed on the component instance. <code>unmount</code> deletes the component base element from the DOM and nulls out all its properties on its instance for garbage collection. As of version 1.2.0, when Composi unmounts a component, it will attempt to unbind a white list of events, passing the component reference to it. This will unbind the events if you used the <code>handleEvent</code> interface. If you used callbacks for events, then you will need to unbind them by passing a refernce to the callback to prevent memory leaks. For earlier versions of Composi it is your responsibility to unbind any events before unmounting to prevent memory leaks.</p>
            <p>Here is the white list of events that get removed automatically:</p>
            <ul>
              <li>click</li>
              <li>dblclick</li>
              <li>mousedown</li>
              <li>mouseup</li>
              <li>mouseover</li>
              <li>mouseout</li>
              <li>mouseover</li>
              <li>mouseleave</li>
              <li>select</li>
              <li>input</li>
              <li>change</li>
              <li>keydown</li>
              <li>keypress</li>
              <li>keyup</li>
              <li>submit</li>
            </ul>
            <p>If you've used other events not in this list, you will need to manually unbind them before unmounting a component.</p>

            <pre>
              <code class="language-javascript">
// Create component instance:
const title = new Title({
  container: 'header',
  state: 'Harry Potter'
})
// Sometime later destory the component:
title.unmount()</code><a name='element'></a>
            </pre>
            
            <p> </p>
            <h2>Component - element</h2>
            <p><a name='componentShouldUpdate'></a>Sometimes you need an easy way to reach child elements in a compnent, either to get a form input value or to register and event. You can do this through the component's <code>element</code> property. <code>element</code> is the base or topmost element of your component's markup. This is not the same as a component's container, which is the element into which a component gets rendered. Many components can exist inside the same container, such as the body tag.</p>

            <h2>Component - componentShouldUpdate</h2>
            <p>This property determines whether Composi should re-render a component when its state changes or its <code>update</code> method is invoked. By default it is set to true. Setting it to false will allow the component to render initially but ignore any other updates. As soon as the property is set back to true, the component will begin updating again.</p>
            <p>This is useful for situations where you need to pause the update of a component while you perform some complex operations.</p>
            
          <pre>
            <code class="language-javascript">
class Hello extends Component {
  constructor(props) {
    super(props)
    this.container = 'header',
    this.state = 'World'
    this.componentShouldUpdate = false
  }
  render: (data) => {
    return (
      &lt;h1>Hello, {data ? `: ${data}`: ''}!&lt;/h1>
    )
  }
}
// Create instance of Hello:
const hello = new Hello()

// Some time later update the component's state:
hello.setState('Joe')
// Because componentShouldUpdate is false, the component will not update.

// Some time later set componentShouldUpdate to true:
hello.componentShouldUpdate = true
hello.setState('Joe')
// Now the component updates.
</code>
          </pre>
            
            <p> </p>
            <h2>Lifecycle Hooks</h2>
            <p>Lifecycle hooks allow you to do things at different times during the existence of a component. Composi has five. These are asynchronous. That means that the event may finish before the hook can. This is probably most important when deal with unmounting. If you have a lot of cleanup to do, do it before unmounting. The two most useful hooks are <code>componentDidMount</code> and <code>componentDidUpdate</code>.<a name='componentWillMount'></a> Before version 1.2.0, we used: <code>beforeCreateComponent</code>. This is now deprecated, so use <code>componentWillMount</code></p>
            
            <a name='componentDidMount'></a>
            <h2>Component - componentWillMount</h2>
            <p>This fires right before the component is rendered and inserted into the DOM. Because of the asynchronous nature of lifecycle hooks, the rendering will probably componente before this method and finish executing. Before version 1.2.0, this was named: <code>componentWasCreated</code>. This is now deprecated, so use <code>componentDidMount</code>.</p>
            
            <a name='componentWillUpdate'></a>
            <h2>Component - componentDidMount</h2>
            <p>This fires right after the component has been injected into the DOM. You can use this to set up events for the component or start a interval loop for some purpose.</p>
            
            <a name='componentDidUpdate'></a>
            <h2>Component - componentWillUpdate</h2>
            <p>This fires right before the component is updated. Updates happen when the <code>update</code> method is invoked, or the <code>state</code> is modified.</p>
            
            <a name='componentWillUnmount'></a>
            <h2>Component - componentDidUpdate</h2>
            <p>This fires right after the component was updated. Updates happen when the <code>update</code> method is invoked, or the <code>state</code> is modified.</p>
            <h2>Component - componentWillUnmount</h2>
            <p>This fires when the </code>unmount</code> method is invoked on the component instance. Because this is asynchronous, it is highly probable that the component will be full unmounted and destroyed before this hook finishes executing.</p>

            <a name='dangerouslySetInnerHTML'></a>
          
            <h2>dangerouslySetInnerHTML</h2>
            <p>This is a property which you can set on any JSX tag. Its purpose is to allow adding data with markup to be rendered unescaped using innerHTML. You put the property on the element into with you wish to insert the data. Then pass the data to the property inside curly braces like any other dynamic property. You can learn more about how to use it <a target='_blank' href='../tuts/introducing-jsx.html#dangerouslySetInnerHTML2'>here</a></p>

          <p>&nbsp;</p>


      </div>

      <aside>
        <menu>
          <ul class="docs__menu">
            <li class="docs__menu__item">
              <a href='./installation.html'>Installation</a>
            </li>
            <li class="docs__menu__item">
              <a href='./render.html'>Render</a>
            </li>
            <li class="docs__menu__item">
              <a href='./functional-components.html'>Functional Components</a>
            </li>
            <li class="docs__menu__item">
              <a href='./component-instance.html'>Component Instance</a>
            </li>
            <li class="docs__menu__item">
              <a href='./extending-component.html'>Extending Component</a>
            </li>
            <li class="docs__menu__item">
              <a href='./state.html'>State</a>
            </li>
            <li class="docs__menu__item">
              <a href='./jsx.html'>JSX</a>
            </li>
            <li class="docs__menu__item">
              <a href='./h.html'>H for Hyperscript</a>
            </li>
            <li class="docs__menu__item">
              <a href='./template-literals.html'>Template Literals</a>
            </li>
            <li class="docs__menu__item">
              <a href='./styles.html'>Styles</a>
            </li>
            <li class="docs__menu__item">
              <a href='./lifecycle-methods.html'>Lifecycle Methods</a>
            </li>
            <li class="docs__menu__item">
              <a href='./events.html'>Events</a>
            </li>
            <li class="docs__menu__item">
              <a href='./hydration.html'>Hydration</a>
            </li>
            <li class="docs__menu__item">
              <a href='./deployment.html'>Deployment</a>
            </li>
            <li class="docs__menu__item selected">
              <a href='./api.html'>API</a>
            </li>
            <li class="docs__menu__item">
              <a href='./about.html'>About</a>
            </li>
          </ul>
        </menu>
      </aside>
    </section> 
  </article>
  <footer>
      <section>
        <svg id='composi-logo-footer' viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <title>Composi Logo</title>
          <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
            <g id="Composi-Logo-Solid" fill="rgba(255,255,255,0.5)">
              <path d="M1.77635684e-15,0 L95,0 L95,38 L209,38 L209,0 L300,0 L300,94 L265,93.8571663 L265,209 L300,209 L300,300 L209,300 L209,265 L95,265 L95,300 L1.77635684e-15,300 L1.77635684e-15,209 L40,209 L40,94 L1.77635684e-15,93.8571663 L1.77635684e-15,0 Z M107,107 L107,192 L192,192 L192,107 L107,107 Z" id="Combined-Shape"></path>
            </g>
          </g>
        </svg>
        <h3>Composi is open source (MIT) and available on <a href='https://github.com/composor/composi' target='__blank'>Github</a> and <a href="https://www.npmjs.com/package/composi" target='__blank'>NPM</a>.</h3>
      </section>
    </footer>
  <script src="../js/prism.min.js"></script>
  <script src="../js/prism-jsx.js"></script>
</body>
</html>