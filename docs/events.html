<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="description" content="Composi is a JavaScript library for creating component-based interfaces. It uses the virtual dom to make efficient updates to the DOM based on a component's data or state.">
  <meta name="keywords" content="javascript, framework, performance, small, fast, UI, programming, code, component, composi, chocolatechipui, chocolatechip-ui, reactive, virtual dom">
  <title>Composi - Docs</title>
  <link rel="stylesheet" href="../css/styles.css">
  <link rel="stylesheet" href="../css/styles.css">
  <link rel="stylesheet" href="../css/prism-tomorrow.css">
</head>
<body class='documentation-page'>
  <nav>
    <ul class='nav--menu'>
      <li class='nav--menu__item'>
        <a class='nav--menu__item__link' href="../index.html">
          <svg id='composi-logo' viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <title>Composi Logo</title>
            <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
              <g id="Composi-Logo-Solid" fill="#fff">
                <path d="M1.77635684e-15,0 L95,0 L95,38 L209,38 L209,0 L300,0 L300,94 L265,93.8571663 L265,209 L300,209 L300,300 L209,300 L209,265 L95,265 L95,300 L1.77635684e-15,300 L1.77635684e-15,209 L40,209 L40,94 L1.77635684e-15,93.8571663 L1.77635684e-15,0 Z M107,107 L107,192 L192,192 L192,107 L107,107 Z" id="Combined-Shape"></path>
              </g>
            </g>
          </svg>
        <span class='logo__link--text'>Composi</span></a>
      </li>
      <li class='nav--menu__item selected'>
        <a class='nav--menu__item__link' href="./installation.html">Docs</a>
      </li>
      <li class='nav--menu__item'>
        <a class='nav--menu__item__link' href="../tuts/index.html">Tutorials</a>
      </li>
      <li class='nav--menu__item'>
        <a class='nav--menu__item__link external' target='__blank' href="https://github.com/composor/awesome-composi">Resources
        <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="14px" height="14px" viewBox="0 0 511.626 511.627" style="enable-background:new 0 0 511.626 511.627;"
	 xml:space="preserve">
  <path fill='#fff' d="M392.857,292.354h-18.274c-2.669,0-4.859,0.855-6.563,2.573c-1.718,1.708-2.573,3.897-2.573,6.563v91.361
    c0,12.563-4.47,23.315-13.415,32.262c-8.945,8.945-19.701,13.414-32.264,13.414H82.224c-12.562,0-23.317-4.469-32.264-13.414
    c-8.945-8.946-13.417-19.698-13.417-32.262V155.31c0-12.562,4.471-23.313,13.417-32.259c8.947-8.947,19.702-13.418,32.264-13.418
    h200.994c2.669,0,4.859-0.859,6.57-2.57c1.711-1.713,2.566-3.9,2.566-6.567V82.221c0-2.662-0.855-4.853-2.566-6.563
    c-1.711-1.713-3.901-2.568-6.57-2.568H82.224c-22.648,0-42.016,8.042-58.102,24.125C8.042,113.297,0,132.665,0,155.313v237.542
    c0,22.647,8.042,42.018,24.123,58.095c16.086,16.084,35.454,24.13,58.102,24.13h237.543c22.647,0,42.017-8.046,58.101-24.13
    c16.085-16.077,24.127-35.447,24.127-58.095v-91.358c0-2.669-0.856-4.859-2.574-6.57
    C397.709,293.209,395.519,292.354,392.857,292.354z"/>
  <path fill='#fff' d="M506.199,41.971c-3.617-3.617-7.905-5.424-12.85-5.424H347.171c-4.948,0-9.233,1.807-12.847,5.424
    c-3.617,3.615-5.428,7.898-5.428,12.847s1.811,9.233,5.428,12.85l50.247,50.248L198.424,304.067
    c-1.906,1.903-2.856,4.093-2.856,6.563c0,2.479,0.953,4.668,2.856,6.571l32.548,32.544c1.903,1.903,4.093,2.852,6.567,2.852
    s4.665-0.948,6.567-2.852l186.148-186.148l50.251,50.248c3.614,3.617,7.898,5.426,12.847,5.426s9.233-1.809,12.851-5.426
    c3.617-3.616,5.424-7.898,5.424-12.847V54.818C511.626,49.866,509.813,45.586,506.199,41.971z"/>
</svg></a>
      </li>
    </ul>
  </nav>
  <article class='docs__article'>
    <section>
      <div class='docs'>
          <h1>Events</h1>
          <p class="docs__intro">You might have the best looking components on the planet, but if there wasn't a way for users to interact with them, they would be essentially useless. There are two ways to implement events:</p>

          <ol>
            <li>inline events</li>
            <li>handleEvent interface</li>
          </ol>

          <p>Inline events are the primary way developers implement events in React, Angular, Vue and other libraries and frameworks. The second way is to create a <code>handleEvent</code> object or method that gets passed to an <code>addEventListener</code> event on the component. Instead of passing the event listener a callback, you pass it an object with a method called <code>handleEvent</code>. This will get called when the event fires. You will usually use the <code>componentWasCreated</code> lifecycle method to set up the event listener.</p>

          <h2>Which to Use</h2>
          <p>Although inline events are in vogue with libraries and frameworks, they can lead to substantial memory usage when you use them on the items of a list of 1000s of items. This can lead to sluggish performance. With the <code>handleEvent</code> interface, you can implement event delegation, reducing memory usage, and there is no callback scope, avoiding the problem of memory leaks. This approach is also safer, reducing the number of attack points for script injection. Event removal is also dead simple.</p>

          <p>If you just want to get things done fast, use inline events. Otherwise use the <code>handleEvent</code> interface. We strongly recommend you give <code>handleEvent</code> a try. If components will be created and destroyed, use the <code>handleEvent</code> interface. It's safer.</p>

          <h2>Inline Events</h2>
          <p>Inline events (DOM Level 0) have been around since 1996. They are the original event system for JavaScript. In versions of Internet Export upto 8, inline events were a source of serious memory leaks that could crash the browser. Composi's support for Internet Explorer starts at version 9, so this is not a concern. You can use inline events with a Component instance or when extending Component. How you do so in each case differs quite a bite. This is due to the way Component instantiation happens. When you create an instance of the Component class, you pass it an object literal of properties. That object literal will not have access to the Component instance, so no <code>this</code>. You'll need to define your callbacks and other custom properties separate from the component initialization.</p>

          
          <p data-height="450" data-theme-id="6688" data-slug-hash="wPBaey" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-1" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/wPBaey/">Composi events-1</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>Notice how in the above example, <code>increase</code> and <code>decrease</code> are separate functions. This may not be a big deal for you, or it may drive you up the wall.</p>

          <h2>Inline Events on Extended Component</h2>
          <p>When we extend the Component class, we can avoid all the above issues of inline event callbacks. This gives us direct access to the component instance through the <code>this</code> keyword and results in code that is more readable and maintainable. To preserve the scope of the component, you do need to bind the inline event. Notice how we do this below:</p>

          <p data-height="450" data-theme-id="6688" data-slug-hash="eemZNQ" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-1a" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/eemZNQ/">Composi events-1a</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>One way to avoid the necessity of binding the inline event is to move that to the constructor:</p>
          
          <p data-height="450" data-theme-id="6688" data-slug-hash="GOgpGP" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-2" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/GOgpGP/">Composi events-2</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p> </p>
          <h2>Arrow Functions for Inline Events</h2>
          <p>Another way to get around having to use <code>bind(this)</code> on your inline events by using arrows functions. To do this, the value of the inline event needs to be an arrow function that returns the component method. Refactoring the <code>render</code> method from above, we get this:</p>

          <pre>
            <code class="language-javascript">
render(data) {
  const {disabled, number} = data
  // Use bind on the inline events:
  return (
    &lt;div class='counter' id={uuid()}>
      &lt;button key='beezle' disabled={disabled} onclick={() => this.decrease()} id="decrease">-&lt;/button>
      &lt;span>{number}&lt;/span>
      &lt;button onclick={() => this.increase()} id="increase">+&lt;/button>
    &lt;/div>
  )
}</code>
          </pre>
          <p> </p>
          <h2>Using handleEvent</h2>
          <p>Perhaps the least used and understood method of handling events has been around since 2000. We're talking about <code>handldeEvent</code>. It's supported in browsers all the way back to IE6. There are two ways you can use the <code>handleEvent</code> interface: as an object or as a class method. The interface might appear a little peculiar at first. This is offset by the benefits it provides over other types of event registration. The biggest benefit of <code>handleEvent</code> is that it reduces memory usage and helps avoid memory leaks.</p>

          <p>The <code>handleEvent</code> interface cannot be used with inline events. It can only be used with <code>addEventListener</code>. It will be the second argument instead of a callback. The <code>handleEvent</code> will be a function defined on that object. There are two ways to do this: as the method of an object literal or as a class method.</p>

          <h2>handleEvent Object</h2>
          <p>To use the <code>handleEvent</code> interface as an object, you just create an object literal that at minumum has <code>handleEvent</code> as a function:</p>

          <pre>
            <code class="language-javascript">
const handler = {
  handleEvent: (e) => {
    // Do stuff here
  }
}</code>
          </pre>
          <p>Let's take a look at how to use a <code>handleEvent</code> object with a Component instance.</p>
          <h2>Component Instance</h2>
          <p>interface. In this case we define a separate object with properties, including the <code>handleEvent</code> method. Notice that the handler object has its own private state that we can access easily from the <code>handleEvent</code> method. To set up the event listener for <code>handleEvent</code> we use the <code>componentWasCreated</code> lifecycle method:</p>

          <p data-height="300" data-theme-id="6688" data-slug-hash="qVEOQo" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-3" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/qVEOQo/">Composi events-3</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>Notice that the <code>handleEvent</code> function in the <code>handler</code> object above has access to other object properties through the <code>this</code> keyword.</p>

          <h2>Component Class Extension</h2>
          <p>Using a <code>handleEvent</code> object when extending the Component class is the same. Like the previous example, we use the <code>componentWasCreated</code> lifecycle method to add an event listener and pass it a <code>handleEvent</code> object:</p>

          <p data-height="300" data-theme-id="6688" data-slug-hash="gXbaZy" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-4" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/gXbaZy/">Composi events-4</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>With the above code, when you click on the title, the console will output the value of the state of <code>handler</code>. Each click will increase its value.</p>

          <h2>handleEvent Method in Components</h2>
          <p>The other way to use the <code>handleEvent</code> interface is as a method of a class. When we extend the Component class, we can make <code>handleEvent</code> one of its methods. Because the <code>handleEvent</code> method is defined directly on the class, we pass the class itself directly to the event listener by means of the <code>this</code> keyword. This means that the <code>handleEvent</code> method will have access to all the properties and methods of the class through normal use of <code>this</code>. Notice how we can directly access the component's state property from within the <code>handleEvent</code> method. Because we are putting this directly on the component class, we this method <code>handleEvent</code>:</p>

          <p data-height="300" data-theme-id="6688" data-slug-hash="MOYaxb" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-5" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/MOYaxb/">Composi events-5</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>In the above code there is no <code>handler</code> object. Instead we've given the component a <code>handleEvent</code> method. When we pass the component to the <code>addEventListener</code> as <code>this</code>, the browser see that this is an object and looks for a method called <code>handleEvent</code>. From there on everything works as expected.</p>

          <h2>Event Delegation with handleEvent</h2>
          <p>In the previous examples, we only registered one event on an element. Inline events allow us to register events that are captured on multiple items. This is useful when you have a list of interactive items. We can implement event delegation with the <code>handleEvent</code> interface as well. It just requires a little extra code on our part.</p>
          <p>Remember that the only argument <code>handleEvent</code> receives is the event. From this we can check the event target to see what the user interacted with. Below is an example doing this:</p>

          <p data-height="500" data-theme-id="6688" data-slug-hash="GOgpeL" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-6" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/GOgpeL/">Composi events-6</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>We could refactor the  <code>handleEvent</code> method to make it a bit cleaner. We'll check the <code>e.target</code> value and use the <code>&&</code> operator to execute a function:</p>

          <pre>
            <code class="language-javascript">
handleEvent(e) {
  // Define function for addItem:
  function addItem(e) {
    const nameInput = this.element.querySelector('#nameInput')
    const name = nameInput.value
    if (!name) {
      alert('Please provide a name!')
      return
    }
    this.setState({name, key: this.key++}, this.state.length)
    nameInput.value = ''
    nameInput.focus()
  }
  // Handle button click:
  e.target.id === 'buttonAdd' && addItem(e)

  // Handle list item click:
  e.target.nodeName === 'LI' && alert(e.target.textContent.trim())
}</code>
          </pre>
          
          <p>As you can see in the above example, <code>handleEvent</code> allows us to implement events in a very efficient manner without any drawbacks. No callback hell with scope issues. If you have a lot of events of the same type on different elements, you can use a switch statement to simplify things. To make your guards simpler, you might resort to using classes on all interactive elements. We've redone the above example to show this approach:</p>

          <p data-height="500" data-theme-id="6688" data-slug-hash="gXbayJ" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-7" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/gXbayJ/">Composi events-7</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p> </p>
          <h2>Removing Event with handleEvent</h2>
          <p>Event removal with <code>handleEvent</code> interface couldn't be simpler. Just use the event and <code>this</code>:</p>

          <pre>
            <code class="language-javascript">
// Example of simple event target:
class List extends Component {
  render(data) {
    return (
      &lt;div>
        &lt;p>
          &lt;button id='remove-event'>Remove Event&lt;/button>
        &lt;/p>
        &lt;ul>
          {
            data.map(item => &lt;li>{item}&lt;/li>)
          }
        &lt;/ul>
      &lt;/div>
    )
  }
  // Handle click on list item and button.
  // Remove event by passing "this" with event.
  handleEvent(e) {
    if (e.target.nodeName === 'LI') {
      alert(e.target.textContent)
    } else if (e.target.id === 'remove-event') {
      this.element.removeEventListener('click', this)
    }
  }

  // Bind event with handleEvent object after component is injected in DOM:
  componentWasCreated() {
    // Add event listener to component base (div):
    this.element.addEventListener('click', this)
  }
}</code>
          </pre>
          <p> </p>
          <h2>Dynamically Changing handleEvent</h2>
          <p>One thing you can easily do with <code>handleEvents</code> that you cnnot do with inline events or ordinary events listeners is change the code for events on the fly. If you've ever tried to do something like this in the past, you probably wound up with callbacks litered with conditional guards. When you use <code>handleEvent</code> to control how an event listener works, this becomes quite simple. It's just a matter of assigning a new value.</p>

          <p>For example, let's say you have a <code>handleEvent</code> method on a class and under certain circumstances you want to change how it functions. Instead of hanving the handler full of conditional checks, you can jsut toggle it for a completely different <code>handleEvent</code>. Let's take a look at how to do this. Below we have a simple list. To switch out the behavior of the <code>handleEvent</code> method, we'll give the class a new method: <code>newHandleEvent</code>. And when we want to switch from the current, default version, we'll just assign it to <code>oldHandleEvent</code>. It's that simple:</p>

          
          <p data-height="500" data-theme-id="6688" data-slug-hash="POwPvr" data-default-tab="js,result" data-user="rbiggs" data-embed-version="2" data-pen-title="Composi events-8" class="codepen">See the Pen <a href="https://codepen.io/rbiggs/pen/POwPvr/">Composi events-8</a> by Robert Biggs (<a href="https://codepen.io/rbiggs">@rbiggs</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
          <p>Because this approach does not involve callbacks, there are no scope issues, DOM memory leaks, etc.</p>

          <h2>Event Target Gotchas</h2>
          <p>Regardless whether you are using inline events or the <code>handleEvent</code> interface, you need to be aware about what the event target could be. In the case of simple markup, there is little to worry about. Suppose you have a simple list of items:</p>

          <pre>
            <code class="language-html">
&lt;ul>
   &lt;li>Apples&lt;/li>
   &lt;li>Oranges&lt;/li>
   &lt;li>Events&lt;/li>
&lt;/ul></code>
          </pre>
          <p>Assuming that an event listener is registered on the list, when the user clicks on a list item, the event target will be the list item. Clicking on the first item:</p>

          <pre>
            <code class="language-javacript">
event.target // &lt;li>Apples&lt;/li>
            </code>
          </pre>
          <p>However, if the item being interacted with has child elements, then the target may not be what you are expecting. Let's look at a more complex list:</p>

          <pre>
            <code class="language-html">
&lt;ul>
   &lt;li>
    &lt;h3>Name: Apples&lt;/h3>
    &lt;h4>Quantity: 4&lt;/h4>
   &lt;/li>
   &lt;li>
    &lt;h3>Oranges&lt;/h3>
    &lt;h4>Quantity: 6&lt;/h4>
   &lt;/li>
   &lt;li>
    &lt;h3>Bananas&lt;/h3>
    &lt;h4>Quantity: 2&lt;/h4>
   &lt;/li>
&lt;/ul></code>
          </pre>
          <p>With an event listener registered on the list, when the user clicks, the event target might be the list item, or the <code>H3</code> or the <code>H4</code>. In cases like this, you'll need to check what the event target is before using it.</p>

          <p>Here is an example of an event target that will always be predictable, in this case, the list item itself:</p>

          <pre>
            <code class="language-javascript">
// Example of simple event target:
class List extends Component {
  // Use arrow function in inline event:
  render(data) {
    return (
      &lt;ul>
        {
          data.map(item => &lt;li onclick={(e) => this.announceItem(e)}>{item}&lt;/li>})
        }
      &lt;/ul>
    )
  }
  announceItem(e) {
    // If user clicked directly on list item:
    e.target.nodeName === 'LI' && alert(e.target.textContent)
  }
}</code>
          </pre>
          <p>Here is a list target that will not be predictable:</p>

          <pre>
            <code class="language-javascript">
// Example of simple event target:
class List extends Component {
  render(data) {
    // Use arrow function in inline event:
    return (
      &lt;ul>
        {
          data.map(item => (
          &lt;li onclick={(e) => this.announceItem(e)}>
            &lt;h3>{item.name}&lt;/h3>
            &lt;h4>{item.value}&lt;/h4>
          &lt;/li>))
        }
      &lt;/ul>
    )
  }
  announceItem(e) {
    // Here e.target might be the list item,
    // or the h3, or the h4:
    alert(e.target.textContent)
  }
}</code>
          </pre>
          <p>To get around the uncertainty of what the event target might be, you'll need to use guards in the callback. In the example below we're using a ternary operator(condition ? result : alternativeResult) to do so:</p>

          <pre>
            <code class="language-javascript">
// Example of simple event target:
class List extends Component {
  render(data) => {
    return (
      &lt;ul>
        {
          data.map(item =>
          &lt;li onclick={(e) => this.announceItem(e)}>
            &lt;h3>{item.name}&lt;/h3>
            &lt;h4>{item.value}&lt;/h4>
          &lt;/li>)
        }
      &lt;/ul>
    )
  }
  announceItem(e) {
    // Here e.target might be the list item,
    // or the h3, or the h4.
    // Therefore we need to test whether the target.nodeName
    // is "LI". If not, we get its parent node:
    const target = e.target.nodeName === 'LI' ? e.target : e.target.parentNode
    // Alert the complete list item content:
    alert(target.textContent)
  }
}
            </code>
          </pre>
          <p> </p>
          <h2>Element.closest</h2>
          <p>In the above example the solution works and it's not hard to implement. However, you may have an interactive element with even more deeply nested children that could be event targets. In such a case, adding more parentNode tree climbing becomes unmanagable. To solve this you can use the <code>Element.closest</code> method. This is available in modern browsers. Composi includes a polyfill for older browsers, so you can use it now to handle these types of situations where you need event delegation. Here's the previous example redone with <code>closest</code>. No matter how complex the list item's children become, we'll always be able to capture the event on the list item itself:</p>

          <pre>
            <code class="language-javascript">
// Example of simple event target:
class List extends Component {
  render(data) {
    return (
      &lt;ul>
        {
          data.map(item => (
            &lt;li onclick={(e) => this.announceItem(e)}>
              &lt;h3>
                &lt;em>{item.name}&lt;/em>
              &lt;/h3>
              &lt;h4>
                &lt;span>{item.value}&lt;/span>
              &lt;/h4>
            &lt;s/li>)
          )
        }
      &lt;/ul>
    )
  }
  announceItem(e) {
    // Use "closest" to test for list item:
    const target = e.target.nodeName === 'LI' ? e.target : e.target.closest('li')
    // Alert the complete list item content:
    alert(target.textContent)
  }
}</code>
          </pre>
          <p> </p>
          <h2>Do Not Mix!</h2>
          <p>It's not a good idea to mix inline events and <code>handleEvent</code> in the same component. If the inline event has the same target as the target used by <code>handleEvent</code> this can lead to weird situations where neither or both may execute. This can lead to situations that are very hard to troubleshoot. So, in a component choose the way you want to handle events and stick to it.</p>


          <p>&nbsp;</p>
          
      </div>

      <aside>
        <menu>
          <ul class="docs__menu">
            <li class="docs__menu__item">
              <a href='./installation.html'>Installation</a>
            </li>
            <li class="docs__menu__item">
              <a href='./render.html'>Render</a>
            </li>
            <li class="docs__menu__item">
              <a href='./functional-components.html'>Functional Components</a>
            </li>
            <li class="docs__menu__item">
              <a href='./component-instance.html'>Component Instance</a>
            </li>
            <li class="docs__menu__item">
              <a href='./extending-component.html'>Extending Component</a>
            </li>
            <li class="docs__menu__item">
              <a href='./state.html'>State</a>
            </li>
            <li class="docs__menu__item">
              <a href='./jsx.html'>JSX</a>
            </li>
            <li class="docs__menu__item">
              <a href='./h.html'>H for Hyperscript</a>
            </li>
            <li class="docs__menu__item">
              <a href='./template-literals.html'>Template Literals</a>
            </li>
            <li class="docs__menu__item">
              <a href='./styles.html'>Styles</a>
            </li>
            <li class="docs__menu__item">
              <a href='./lifecycle-methods.html'>Lifecycle Methods</a>
            </li>
            <li class="docs__menu__item selected">
              <a href='./events.html'>Events</a>
            </li>
            <li class="docs__menu__item">
              <a href='./hydration.html'>Hydration</a>
            </li>
            <li class="docs__menu__item">
              <a href='./deployment.html'>Deployment</a>
            </li>
            <li class="docs__menu__item">
              <a href='./api.html'>API</a>
            </li>
            <li class="docs__menu__item">
              <a href='./about.html'>About</a>
            </li>
          </ul>
        </menu>
      </aside>
    </section> 
  </article>
  <footer>
      <section>
        <svg id='composi-logo-footer' viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <title>Composi Logo</title>
          <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
            <g id="Composi-Logo-Solid" fill="rgba(255,255,255,0.5)">
              <path d="M1.77635684e-15,0 L95,0 L95,38 L209,38 L209,0 L300,0 L300,94 L265,93.8571663 L265,209 L300,209 L300,300 L209,300 L209,265 L95,265 L95,300 L1.77635684e-15,300 L1.77635684e-15,209 L40,209 L40,94 L1.77635684e-15,93.8571663 L1.77635684e-15,0 Z M107,107 L107,192 L192,192 L192,107 L107,107 Z" id="Combined-Shape"></path>
            </g>
          </g>
        </svg>
        <h3>Composi is open source (MIT) and available on <a href='https://github.com/composor/composi' target='__blank'>Github</a> and <a href="https://www.npmjs.com/package/composi" target='__blank'>NPM</a>.</h3>
      </section>
    </footer>
  <script src="../js/prism.min.js"></script>
  <script src="../js/prism-jsx.js"></script>
</body>
</html>